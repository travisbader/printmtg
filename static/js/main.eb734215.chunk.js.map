{"version":3,"sources":["scryfall.js","CardContext.js","Header.js","Controls/ToggleSwitch.js","Settings.js","DeckList.js","Cards.js","App.js","serviceWorker.js","index.js"],"names":["cardName","preferPromo","preferNonPromo","prefersNewest","a","url","encodeURI","headers","fetch","method","then","res","json","catch","error","console","list","object","total_cards","data","matches","filter","card","name","toUpperCase","promos","promo","length","findCard","CardContext","React","createContext","ignored","CardProvider","props","useState","deckList","setDeckList","errors","setErrors","foundCards","setFoundCards","isLoading","setIsLoading","prefersPromo","setPrefersPromo","prefersNonPromo","setPrefersNonPromo","setPrefersNewest","cropBorders","setCropBorders","regex","cards","m","exec","index","lastIndex","includes","trim","toLowerCase","push","searchText","quantity","images","Promise","all","map","c","image_uris","border_crop","card_faces","cardFace","Provider","value","findCards","children","Header","useContext","className","ToggleSwitch","id","checked","onChange","optionLabels","small","disabled","type","e","target","tabIndex","onKeyDown","keyCode","preventDefault","handleKeyPress","htmlFor","data-yes","data-no","defaultProps","Settings","newVal","DeckList","localDeckList","setLocalDecklist","i","key","onClick","slice","concat","placeholder","onSubmit","Cards","arr","size","temp","flat","groupedCards","Array","from","Math","ceil","v","image","imageIndex","src","alt","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.eb734215.chunk.js","sourcesContent":["async function findCard(cardName, preferPromo, preferNonPromo, prefersNewest) {\n    if (typeof(cardName) !== 'string') {\n        return;\n    }\n\n  const url = encodeURI('https://api.scryfall.com/cards/search?&q=' + cardName + '&unique=prints&order=released&dir=' + (prefersNewest ? 'desc' : 'asc'));\n  const headers = { 'Origin': 'http://localhost:3000' };\n  const list = await fetch(url,  { method: 'GET', headers: headers })\n  .then(res => res.json())\n  .catch(error => console.error(error))\n\n  if (list?.object !== 'list') {\n    return null;\n  }\n  else if (list.total_cards === 0) {\n    return null;\n  }\n  else if (list.total_cards === 1) {\n    return list.data[0];\n  }\n  else {\n    let matches = list.data.filter(card => \n      card.name.toUpperCase() === cardName.toUpperCase()\n    );\n    if (preferPromo) {\n      const promos = matches.filter(card => card.promo)\n      if (promos.length > 0) {\n        return promos[0];\n      }\n    }\n    else if (preferNonPromo) {\n      const promos = matches.filter(card => !card.promo)\n      if (promos.length > 0) {\n        return promos[0];\n      }\n    }\n    if (matches.length > 0) {\n      return matches[0];\n    }\n    else {\n      return list.data[0];\n    }\n  }\n}\n\nexport default findCard;","import React, { useState } from 'react'\nimport findCard from './scryfall'\n\nexport const CardContext = React.createContext();\nconst ignored = [\"sideboard\", 'maybeboard', ''];\n\nexport const CardProvider = (props) => {\n  const [deckList, setDeckList] = useState(\"opt\")\n  const [errors, setErrors] = useState([]);  \n  const [foundCards, setFoundCards] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [prefersPromo, setPrefersPromo] = useState(false);\n  const [prefersNonPromo, setPrefersNonPromo] = useState(false);\n  const [prefersNewest, setPrefersNewest] = useState(true);\n  const [cropBorders, setCropBorders] = useState(false);\n\n  async function findCards(deckList) {\n    setIsLoading(true);\n    const regex = /^([0-9]*)[\\s]*([\\w ',+]+)*$/gm;\n    var cards = [];\n    let m;\n\n    while ((m = regex.exec(deckList)) !== null) {\n      // This is necessary to avoid infinite loops with zero-width matches\n      if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n      }\n      if (!ignored.includes(m[0]?.trim().toLowerCase())) {\n        cards.push({\n          searchText: m[0]?.trim(),\n          quantity: m[1] ? m[1] : 1,\n          name: m[2]?.trim(),\n          images: null\n        });\n      }\n    }\n\n    var errors = [];\n    await Promise.all(cards.map(async (c, index) => {\n      const card = await findCard(c.name, prefersPromo, prefersNonPromo, prefersNewest, cropBorders)\n      if (card == null) {\n        errors.push(c.searchText + ' could not be found \\r\\n');\n      }\n      else if (card[\"object\"] === 'error') {\n        errors.push(c.searchText + ' could not be found \\r\\n');\n      }\n      else if (cropBorders && card.image_uris?.border_crop) {\n        c.images = card.image_uris.border_crop;\n      }\n      else {\n        c.images = (card.card_faces) ? card.card_faces.map((cardFace) => {\n          return cardFace.image_uris[\"large\"]}) : [card.image_uris[\"large\"] ]\n      }\n    }));\n\n    setFoundCards(cards);\n    setDeckList(deckList);\n    setErrors(errors);\n    setIsLoading(false);\n}\n\n  return (\n    <CardContext.Provider value={{\n        deckList, setDeckList,\n        foundCards, setFoundCards, findCards,\n        errors, setErrors,\n        prefersPromo, setPrefersPromo,\n        prefersNonPromo, setPrefersNonPromo,\n        prefersNewest, setPrefersNewest,\n        cropBorders, setCropBorders,\n        isLoading\n        }}>\n      {props.children}\n    </CardContext.Provider>\n  )\n}","import React, { useContext } from 'react';\nimport { CardContext } from './CardContext';\nimport './Header.css';\n\nfunction Header() {\n    const { isLoading, errors } = useContext(CardContext)\n    return(\n        <div className=\"header\">\n          <header className=\"appHeader\">\n              Print Magic Cards\n          </header>\n          {errors.length === 0 ?\n          <p> {isLoading ? \n          \"Loading...\" :\n          \"Enter Your Decklist\"}</p> : null}\n        </div>\n    )\n}\n\nexport default Header;","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"./ToggleSwitch.scss\";\n\n/*\nToggle Switch Component\nNote: id, checked and onChange are required for ToggleSwitch component to function. The props name, small, disabled\nand optionLabels are optional.\nUsage: <ToggleSwitch id=\"id\" checked={value} onChange={checked => setValue(checked)}} />\n*/\n\nconst ToggleSwitch = ({\n  id,\n  name,\n  checked,\n  onChange,\n  optionLabels,\n  small,\n  disabled\n}) => {\n  function handleKeyPress(e) {\n    if (e.keyCode !== 32) return;\n\n    e.preventDefault();\n    onChange(!checked);\n  }\n\n  return (\n    <div className={\"toggle-switch\" + (small ? \" small-switch\" : \"\")}>\n      <input\n        type=\"checkbox\"\n        name={name}\n        className=\"toggle-switch-checkbox\"\n        id={id}\n        checked={checked}\n        onChange={(e) => onChange(e.target.checked)}\n        disabled={disabled}\n      />\n      {id ? (\n        <label\n          className=\"toggle-switch-label\"\n          tabIndex={disabled ? -1 : 1}\n          onKeyDown={(e) => handleKeyPress(e)}\n          htmlFor={id}\n        >\n          <span\n            className={\n              disabled\n                ? \"toggle-switch-inner toggle-switch-disabled\"\n                : \"toggle-switch-inner\"\n            }\n            data-yes={optionLabels[0]}\n            data-no={optionLabels[1]}\n            tabIndex={-1}\n          />\n          <span\n            className={\n              disabled\n                ? \"toggle-switch-switch toggle-switch-disabled\"\n                : \"toggle-switch-switch\"\n            }\n            tabIndex={-1}\n          />\n        </label>\n      ) : null}\n    </div>\n  );\n};\n\n// Set optionLabels for rendering.\nToggleSwitch.defaultProps = {\n  optionLabels: [\"Yes\", \"No\"]\n};\n\nToggleSwitch.propTypes = {\n  id: PropTypes.string.isRequired,\n  checked: PropTypes.bool.isRequired,\n  onChange: PropTypes.func.isRequired,\n  name: PropTypes.string,\n  optionLabels: PropTypes.array,\n  small: PropTypes.bool,\n  disabled: PropTypes.bool\n};\n\nexport default ToggleSwitch;\n","import React, { useContext } from 'react';\nimport ToggleSwitch from '../src/Controls/ToggleSwitch'\nimport { CardContext } from './CardContext'\nimport './Settings.css';\n\nfunction Settings() {\n    const { prefersPromo, setPrefersPromo, prefersNonPromo, setPrefersNonPromo, prefersNewest, setPrefersNewest, cropBorders, setCropBorders} = useContext(CardContext)\n\n    return(\n        <div className=\"settingsContainer\">\n            <div className=\"promosToggle\">\n                <label className=\"toggleLabel\">Prefer Promo </label>\n                <ToggleSwitch\n                    id=\"promo\"\n                    small\n                    checked={prefersPromo}\n                    onChange={ newVal => {\n                        if(newVal) {\n                            setPrefersNonPromo(false);\n                        }\n                        setPrefersPromo(newVal)\n                        }\n                    }/>\n            </div>\n            <div className=\"promosToggle\">\n                <label className=\"toggleLabel\">Prefer Non Promo</label>\n                <ToggleSwitch\n                    id=\"nonPromo\"\n                    small\n                    checked={prefersNonPromo}\n                    onChange={ newVal => {\n                        if(newVal) {\n                            setPrefersPromo(false);\n                        }\n                        setPrefersNonPromo(newVal)\n                        }\n                    }/>\n            </div>\n            <div className=\"promosToggle\">\n                <label className=\"toggleLabel\">Prefer Newer</label>\n                <ToggleSwitch\n                    id=\"newest\"\n                    small\n                    checked={prefersNewest}\n                    onChange={setPrefersNewest}/>\n            </div>\n            <div className=\"promosToggle\">\n                <label className=\"toggleLabel\">Crop Borders</label>\n                <ToggleSwitch\n                    id=\"clip\"\n                    small\n                    checked={cropBorders}\n                    onChange={setCropBorders}/>\n            </div>\n        </div>\n    );\n}\n\nexport default Settings;","import React, { useState, useContext } from 'react';\nimport { CardContext } from './CardContext'\nimport Settings from './Settings'\n\nimport './Decklist.css';\n\nfunction DeckList() {\n    \n    const { findCards, isLoading, errors, setErrors} = useContext(CardContext)\n    const [localDeckList, setLocalDecklist] = useState('');\n\n    async function onSubmit() {\n        if (!localDeckList) {\n          setErrors(['Enter a decklist to begin'])\n          return;\n        }\n        findCards(localDeckList);\n    }\n\n    return (\n        <div className=\"inputContainer\">\n            {errors.length > 0 ?\n                errors.map((error, i) => {\n                    return(\n                        <div className=\"errorBanner\" key={\"error \" + i}>\n                            <button className=\"translucentButton\" onClick={ () => {\n                                //can't beleive this is the best way to remove an item at index in js\n                                setErrors(errors.slice(0, i).concat(errors.slice(i + 1, errors.length)));\n                            }}>X</button>\n                        <div className=\"errorMessage\">{ error }</div>\n                    <div/>\n                </div>\n               )\n           })\n           \n           : null\n            }\n            { !isLoading ?\n                <div className=\"inputContainer\">\n                    <textarea\n                        placeholder=\"Enter your decklist here in the following format:&#10;1 Opt&#10;1 Remand&#10;1 Reverberate&#10;...\"\n                        onChange={e => {\n                            setErrors([])\n                            setLocalDecklist(e.target.value)\n                            }\n                        }\n                        value={localDeckList}\n                    />\n                    <Settings />\n                    <button className=\"submitButton\" onClick={ () => {\n                            onSubmit()}}>Submit\n                    </button>\n                </div> : null\n            }\n        </div>\n        );\n    }\n\nexport default DeckList;","import React, { useContext } from 'react';\nimport './Cards.css';\nimport { CardContext } from './CardContext';\n\nconst chunk = (arr, size) =>\n  Array.from({ length: Math.ceil(arr.length / size) }, (v, i) =>\n    arr.slice(i * size, i * size + size)\n  );\n\nfunction Cards() {\n    const { foundCards, isLoading } = useContext(CardContext)\n    \n    const images = foundCards\n    .filter(card => card.images?.length > 0)\n    .map(card => {\n        var temp = [];\n        for (var index = 0; index < card.quantity; index++) {\n            temp.push(card.images)\n        }\n        return temp.flat();\n    }).flat();\n    \n    const groupedCards =  chunk(images, 9);\n\n    return (\n        <div className=\"cardPreview\">\n            { groupedCards.map((images, index) => {\n                return(\n                    isLoading ? null :\n                <div className=\"cardGroup\" key={index}>\n                    { images.map((image, imageIndex) => {\n                        return(\n                            <div className=\"cardContainer\" key={imageIndex}>\n                                <img src={image} alt={image} />\n                            </div>\n                        )\n                    })\n                    }\n                </div>)\n            })\n            }\n        </div>)\n}\n\nexport default Cards;\n","import React from 'react';\nimport Header from './Header';\nimport Decklist from './DeckList';\nimport Cards from './Cards';\nimport { CardProvider } from './CardContext';\n\nimport './App.css';\n\nfunction App() {\n  return (\n    <CardProvider>\n        <div className=\"app\">\n          <Header />\n          <Decklist />\n          <Cards />\n        </div>\n    </CardProvider>\n  );\n}\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}